# coding: utf-8
import sys
import socket
import getpass
import pymesos as mesos
from mesos.interface import Scheduler
from mesos.interface import mesos_pb2

import logging
logging.basicConfig(level=logging.INFO)

TOTAL_TASKS = 5
TASK_CPUS = 0.1
TASK_MEM = 1


class HelloWorldScheduler(Scheduler):
    def __init__(self):
        self.tasksLaunched = 0
        self.tasksFinished = 0
        self.shuttingDown = False

    def registered(self, driver, frameworkId, masterInfo):
        """
        Invoked when the scheduler successfully registers with a Mesos master.
        It is called with the frameworkId, a unique ID generated by the
        master, and the masterInfo which is information about the master
        itself.
        """
        logging.info("Registered with driver(%s), frameworkId(%s), masterInfo(%s)",
                     driver, frameworkId, masterInfo)

    def resourceOffers(self, driver, offers):
        """
        Invoked when resources have been offered to this framework. A single
        offer will only contain resources from a single slave.  Resources
        associated with an offer will not be re-offered to _this_ framework
        until either (a) this framework has rejected those resources (see
        SchedulerDriver.launchTasks) or (b) those resources have been
        rescinded (see Scheduler.offerRescinded).  Note that resources may be
        concurrently offered to more than one framework at a time (depending
        on the allocator being used).  In that case, the first framework to
        launch tasks using those resources will be able to use them while the
        other frameworks will have those resources rescinded (or if a
        framework has already launched tasks with those resources then those
        tasks will fail with a TASK_LOST status and a message saying as much).
        """
        self.logStatistics()
        rf = mesos_pb2.Filters()
        rf.refuse_seconds = 5

        for offer in offers:
            logging.info("Got resource offer [%s]", offer.id.value)
            if self.shuttingDown or self.tasksLaunched >= TOTAL_TASKS:
                logging.info("declining offer on [%s]", offer.hostname)
                driver.declineOffer(offer.id, rf)
                continue

            maxTasks = self.maxTasksForOffer(offer)
            logging.info("maxTasks: [%d]", maxTasks)
            tasks = []

            for _ in range(min(maxTasks, TOTAL_TASKS)):
                task = self.makeTask(offer)
                tasks.append(task)

            if tasks:
                logging.info("Accepting offer on [%s]", offer.hostname)
                driver.launchTasks(offer.id, tasks, rf)
            else:
                logging.info("Declining offer on [%s]", offer.hostname)
                driver.declineOffer(offer.id, rf)

    def makeTask(self, offer):
        task = mesos_pb2.TaskInfo()
        tid = self.tasksLaunched
        self.tasksLaunched += 1
        task.task_id.value = str(tid)
        task.slave_id.value = offer.slave_id.value
        task.name = "Task_%s" % tid
        task.command.value = "echo hello world"

        cpus = task.resources.add()
        cpus.name = "cpus"
        cpus.type = mesos_pb2.Value.SCALAR
        cpus.scalar.value = TASK_CPUS

        mem = task.resources.add()
        mem.name = "mem"
        mem.type = mesos_pb2.Value.SCALAR
        mem.scalar.value = TASK_MEM
        return task

    def logStatistics(self):
        logging.info("Tasks: %d launched, %d finished.",
                     self.tasksLaunched, self.tasksFinished)

    def maxTasksForOffer(self, offer):
        count = 0
        for rsc in offer.resources:
            if rsc.name == 'cpus':
                cpus = rsc.scalar.value
            elif rsc.name == 'mem':
                mem = rsc.scalar.value
        while cpus >= TASK_CPUS and mem >= TASK_MEM:
            count += 1
            cpus -= TASK_CPUS
            mem -= TASK_MEM
        return count

    def statusUpdate(self, driver, update):
        """
        Invoked when the status of a task has changed (e.g., a slave is
        lost and so the task is lost, a task finishes and an executor
        sends a status update saying so, etc). If implicit
        acknowledgements are being used, then returning from this
        callback _acknowledges_ receipt of this status update! If for
        whatever reason the scheduler aborts during this callback (or
        the process exits) another status update will be delivered (note,
        however, that this is currently not true if the slave sending the
        status update is lost/fails during that time). If explicit
        acknowledgements are in use, the scheduler must acknowledge this
        status on the driver.
        """
        stateName = mesos_pb2.TaskState.Name(update.state)
        logging.info("Task [%s] is in state [%s]", update.task_id.value, stateName)

        if update.state == mesos_pb2.TASK_FINISHED:
            self.tasksFinished += 1
            if self.tasksFinished == TOTAL_TASKS:
                logging.info("All tasks done.")
                driver.abort()

        elif update.state in (mesos_pb2.TASK_LOST,
                              mesos_pb2.TASK_KILLED,
                              mesos_pb2.TASK_FAILED):
            logging.info("Aborting because task [%s] is in unexpected state [%s] with message [%s]",
                         update.task_id.value, stateName, update.message)
            driver.abort()


def getUser():
    return getpass.getuser()


def main():
    if len(sys.argv) != 2:
        print "Usage: %s master" % sys.argv[0]
        sys.exit(1)

    framework = mesos_pb2.FrameworkInfo()
    framework.user = getUser()
    framework.name = "Hello-World"
    framework.hostname = socket.gethostname()
    driver = mesos.MesosSchedulerDriver(
        HelloWorldScheduler(),
        framework,
        master_uri=sys.argv[1]
    )
    driver.run()


if __name__ == '__main__':
    main()
